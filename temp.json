{
  "success": true,
  "message": "Contracts generated and saved to files successfully",
  "contracts": {
    "governanceToken": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/**\n * @title MetaDAO Governance Token\n * @dev Governance token for MetaDAO DAO\n */\ncontract METAToken is ERC20Votes, AccessControl {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    \n    constructor() \n        ERC20(\"MetaDAO Governance Token\", \"META\") \n        ERC20Permit(\"MetaDAO Governance Token\")\n    {\n        _grantRole(DEFAULT_ADMIN_ROLE, 0xabcdefabcdefabcdefabcdefabcdefabcdefabcd);\n        _grantRole(MINTER_ROLE, 0xabcdefabcdefabcdefabcdefabcdefabcdefabcd);\n    }\n    \n    function mint(address to, uint256 amount) external onlyRole(MINTER_ROLE) {\n        _mint(to, amount);\n    }\n    \n    // The functions below are overrides required by Solidity\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal override(ERC20Votes) {\n        super._afterTokenTransfer(from, to, amount);\n    }\n\n    function _mint(address to, uint256 amount) internal override(ERC20Votes) {\n        super._mint(to, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal override(ERC20Votes) {\n        super._burn(account, amount);\n    }\n}",
    "governanceContract": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/governance/Governor.sol\";\nimport \"@openzeppelin/contracts/governance/extensions/GovernorSettings.sol\";\nimport \"@openzeppelin/contracts/governance/extensions/GovernorCountingSimple.sol\";\nimport \"@openzeppelin/contracts/governance/extensions/GovernorVotes.sol\";\nimport \"@openzeppelin/contracts/governance/extensions/GovernorVotesQuorumFraction.sol\";\nimport \"@openzeppelin/contracts/governance/extensions/GovernorTimelockControl.sol\";\n\n/**\n * @title MetaDAO Governance\n * @dev A DAO for governing fund distribution\n * Purpose: Decentralized funding of projects\n */\ncontract MetaDAOGovernance is \n    Governor, \n    GovernorSettings, \n    GovernorCountingSimple, \n    GovernorVotes, \n    GovernorVotesQuorumFraction, GovernorTimelockControl {\n    \n    constructor(IVotes _token, TimelockController _timelock)\n        Governor(\"MetaDAO Governance\")\n        GovernorSettings(1, 19636, 0) // votingDelay, votingPeriod, proposal threshold\n        GovernorVotes(_token)\n        GovernorVotesQuorumFraction(5)\n        GovernorTimelockControl(_timelock)\n    {}\n\n    // The following functions are overrides required by Solidity.\n    function votingDelay() public view override(IGovernor, GovernorSettings) returns (uint256) {\n        return super.votingDelay();\n    }\n\n    function votingPeriod() public view override(IGovernor, GovernorSettings) returns (uint256) {\n        return super.votingPeriod();\n    }\n\n    function quorum(uint256 blockNumber) public view override(IGovernor, GovernorVotesQuorumFraction) returns (uint256) {\n        return super.quorum(blockNumber);\n    }\n\n    function state(uint256 proposalId) public view override(Governor, GovernorTimelockControl) returns (ProposalState) {\n        return super.state(proposalId);\n    }\n\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public override(Governor, IGovernor) returns (uint256) {\n        return super.propose(targets, values, calldatas, description);\n    }\n\n    function proposalThreshold() public view override(Governor, GovernorSettings) returns (uint256) {\n        return super.proposalThreshold();\n    }\n\n    \n    function _execute(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal override(Governor, GovernorTimelockControl) {\n        super._execute(proposalId, targets, values, calldatas, descriptionHash);\n    }\n\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal override(Governor, GovernorTimelockControl) returns (uint256) {\n        return super._cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    function _executor() internal view override(Governor, GovernorTimelockControl) returns (address) {\n        return super._executor();\n    }\n    \n\n    function supportsInterface(bytes4 interfaceId) public view override(Governor, GovernorTimelockControl) returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n}\n\n\n/**\n * @title MetaDAO Timelock Controller\n */\ncontract MetaDAOTimelock is TimelockController {\n    constructor(\n        uint256 minDelay,\n        address[] memory proposers,\n        address[] memory executors,\n        address admin\n    ) TimelockController(minDelay, proposers, executors, admin) {}\n}\n\n// Deployment script should include:\n// 1. Deploy token\n// 2. Deploy timelock with appropriate delay (e.g., 2 days = 172800 seconds)\n// 3. Setup roles: admin=0xabcdefabcdefabcdefabcdefabcdefabcdefabcd, treasury=0x1234567890123456789012345678901234567890\n// 4. Deploy governance with token and timelock\n"
  },
  "filePaths": {
    "tokenPath": "generated-contracts/METAToken.sol",
    "governancePath": "generated-contracts/MetaDAOGovernance.sol"
  }
}
